# -*- coding: utf-8 -*-
"""telegram bulk messege sender

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sRBr31mRykE5bZ2C4PTeoZMrwe3MK5_9
"""

# ğŸš€ TELEGRAM API USER ACCOUNT SENDER
# =============================================================================
# CELL 1: Î•Î³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·
# =============================================================================
!pip install pyrogram tgcrypto pandas openpyxl -q
print("âœ… Dependencies ÎµÎ³ÎºÎ±Ï„Î±ÏƒÏ„Î¬Î¸Î·ÎºÎ±Î½!")

# =============================================================================
# CELL 2: User Account Setup
# =============================================================================
from pyrogram import Client
import pandas as pd
import asyncio
import time
from IPython.display import clear_output

API_ID =   # Î‘Ï€ÏŒ my.telegram.org
API_HASH = ""  # Î‘Ï€ÏŒ my.telegram.org
PHONE_NUMBER = ""  # Î¤ÎŸ Î”Î™ÎšÎŸ ÏƒÎ±Ï‚ Ï„Î·Î»Î­Ï†Ï‰Î½Î¿

# ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ credentials
if API_HASH == "your_api_hash_here":
    print("âŒ Î’Î‘Î›Î¤Î• Î¤Î‘ API CREDENTIALS!")
    print("ğŸ”— Î‘Ï€ÏŒ: https://my.telegram.org/")
    print("âš ï¸ Î Î¡ÎŸÎ£ÎŸÎ§Î—: User account API, ÏŒÏ‡Î¹ bot token!")
else:
    print("âœ… User API credentials Î­Ï‡Î¿Ï…Î½ Î¿ÏÎ¹ÏƒÏ„ÎµÎ¯!")


# =============================================================================
# CELL 3: Simple User Account Sender
# =============================================================================
class TelegramUserSender:
    def __init__(self, api_id, api_hash, phone_number):
        self.api_id = api_id
        self.api_hash = api_hash
        self.phone_number = phone_number
        # User account client (ÏŒÏ‡Î¹ bot!)
        self.app = Client(
            "user_session",  # Session name
            api_id=api_id,
            api_hash=api_hash,
            phone_number=phone_number
        )

    async def start_session(self):
        """ÎÎµÎºÎ¹Î½Î¬ÎµÎ¹ user session"""
        print("ğŸ” ÎÎµÎºÎ¹Î½Î¬Ï‰ user session...")
        await self.app.start()

        # User info
        me = await self.app.get_me()
        print(f"âœ… Î£Ï…Î½Î´Î­Î¸Î·ÎºÎ± Ï‰Ï‚: {me.first_name} {me.last_name or ''}")
        print(f"ğŸ“± Username: @{me.username or 'Î§Ï‰ÏÎ¯Ï‚ username'}")
        print(f"ğŸ“ Î¤Î·Î»Î­Ï†Ï‰Î½Î¿: {me.phone_number}")
        print("ğŸ¯ User account mode - Full access!")
        return True

    async def send_to_phone(self, phone_number, message):
        """Î£Ï„Î­Î»Î½ÎµÎ¹ Î¼Î®Î½Ï…Î¼Î± ÏƒÎµ Ï„Î·Î»Î­Ï†Ï‰Î½Î¿ Î¼Îµ contact import fallback"""
        try:
            # ÎšÎ±Î¸Î±ÏÎ¹ÏƒÎ¼ÏŒÏ‚ Ï„Î·Î»ÎµÏ†ÏÎ½Î¿Ï…
            if not phone_number.startswith('+'):
                phone_number = f'+{phone_number}'

            # Î£Î¤Î¡Î‘Î¤Î—Î“Î™ÎšÎ— 1: Î†Î¼ÎµÏƒÎ· Î±Ï€Î¿ÏƒÏ„Î¿Î»Î®
            try:
                await self.app.send_message(phone_number, message)
                return {'success': True, 'error': None}
            except Exception as e1:
                print(f"      âš ï¸ Direct send failed: {str(e1)[:50]}")

            # Î£Î¤Î¡Î‘Î¤Î—Î“Î™ÎšÎ— 2: Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ· ÏƒÏ„Î¹Ï‚ ÎµÏ€Î±Ï†Î­Ï‚ Ï€ÏÏÏ„Î±
            try:
                print("      ğŸ”„ Trying contact import...")

                # Import contact using raw API
                from pyrogram.raw.functions.contacts import ImportContacts
                from pyrogram.raw.types import InputPhoneContact

                contact = InputPhoneContact(
                    client_id=0,
                    phone=phone_number.replace('+', ''),
                    first_name="Contact",
                    last_name=""
                )

                result = await self.app.invoke(ImportContacts(contacts=[contact]))

                if result.users:
                    user = result.users[0]
                    await self.app.send_message(user.id, message)
                    return {'success': True, 'error': None}
                else:
                    return {'success': False, 'error': 'Contact import failed - Ï‡ÏÎ®ÏƒÏ„Î·Ï‚ Î´ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ'}

            except Exception as e2:
                print(f"      âš ï¸ Contact import failed: {str(e2)[:50]}")

            # Î£Î¤Î¡Î‘Î¤Î—Î“Î™ÎšÎ— 3: Î ÏÎ¿ÏƒÏ€Î¬Î¸ÎµÎ¹Î± Î¼Îµ resolve users
            try:
                print("      ğŸ”„ Trying user resolution...")
                user = await self.app.get_users(phone_number)
                await self.app.send_message(user.id, message)
                return {'success': True, 'error': None}
            except Exception as e3:
                print(f"      âš ï¸ User resolution failed: {str(e3)[:50]}")

            # Î‘Î½ ÏŒÎ»ÎµÏ‚ Î±Ï€Î­Ï„Ï…Ï‡Î±Î½
            return {'success': False, 'error': 'Î§ÏÎ®ÏƒÏ„Î·Ï‚ Î´ÎµÎ½ Î¼Ï€Î¿ÏÎµÎ¯ Î½Î± Î»Î¬Î²ÎµÎ¹ Î¼Î·Î½ÏÎ¼Î±Ï„Î± (privacy settings)'}

        except Exception as e:
            error_str = str(e)

            # Î•Î¹Î´Î¹ÎºÎ¬ errors
            if "PEER_ID_INVALID" in error_str:
                return {'success': False, 'error': 'Î§ÏÎ®ÏƒÏ„Î·Ï‚ Î´ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ Î® privacy restrictions'}
            elif "USER_IS_BLOCKED" in error_str:
                return {'success': False, 'error': 'Î£Î±Ï‚ Î­Ï‡ÎµÎ¹ Î¼Ï€Î»Î¿ÎºÎ¬ÏÎµÎ¹'}
            elif "CHAT_WRITE_FORBIDDEN" in error_str:
                return {'success': False, 'error': 'Î”ÎµÎ½ ÎµÏ€Î¹Ï„ÏÎ­Ï€ÎµÏ„Î±Î¹ Î¼Î®Î½Ï…Î¼Î± (privacy)'}
            elif "FLOOD_WAIT" in error_str:
                import re
                wait_time = re.findall(r'FLOOD_WAIT_(\d+)', error_str)
                wait_seconds = wait_time[0] if wait_time else '60'
                return {'success': False, 'error': f'Rate limit - Ï€ÎµÏÎ¹Î¼Î­Î½ÎµÏ„Îµ {wait_seconds}s'}
            else:
                return {'success': False, 'error': error_str}

    async def bulk_send_simple(self, phone_list, message, delay=5):
        """Î‘Ï€Î»Î® Î¼Î±Î¶Î¹ÎºÎ® Î±Ï€Î¿ÏƒÏ„Î¿Î»Î®"""
        results = {
            'total': len(phone_list),
            'sent': 0,
            'failed': 0,
            'blocked': 0,
            'errors': []
        }

        print(f"ğŸš€ ÎœÎ±Î¶Î¹ÎºÎ® Î±Ï€Î¿ÏƒÏ„Î¿Î»Î® ÏƒÎµ {len(phone_list)} Ï„Î·Î»Î­Ï†Ï‰Î½Î±...")
        print("=" * 50)

        for i, phone in enumerate(phone_list, 1):
            # Progress
            progress = i / len(phone_list) * 100

            clear_output(wait=True)
            print(f"ğŸš€ Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®: {progress:.1f}% ({i}/{len(phone_list)})")
            print(f"ğŸ“± Î¤Î·Î»Î­Ï†Ï‰Î½Î¿: {phone}")
            print(f"âœ… Î•Ï€Î¹Ï„Ï…Ï‡Î®: {results['sent']} | âŒ Î‘Ï€Î¿Ï„Ï…Ï‡Î¯ÎµÏ‚: {results['failed']}")

            # Î‘Ï€Î¿ÏƒÏ„Î¿Î»Î®
            result = await self.send_to_phone(phone, message)

            if result['success']:
                results['sent'] += 1
                print("      âœ… Î£Ï„Î¬Î»Î¸Î·ÎºÎµ!")
            else:
                results['failed'] += 1
                error = result['error']
                results['errors'].append(f"{phone}: {error}")
                print(f"      âŒ Î£Î¦Î‘Î›ÎœÎ‘: {error}")

                # Detailed error logging
                if 'PEER_ID_INVALID' in str(error):
                    print("      ğŸ’¡ Î§ÏÎ®ÏƒÏ„Î·Ï‚ Î´ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ - Î¼Î¬Î»Î»Î¿Î½ Î´ÎµÎ½ Î­Ï‡ÎµÎ¹ Telegram")
                elif 'Î¼Ï€Î»Î¿ÎºÎ¬ÏÎµÎ¹' in error:
                    results['blocked'] += 1
                    print("      ğŸš« ÎŸ Ï‡ÏÎ®ÏƒÏ„Î·Ï‚ ÏƒÎ±Ï‚ Î­Ï‡ÎµÎ¹ Î¼Ï€Î»Î¿ÎºÎ¬ÏÎµÎ¹")
                elif 'FLOOD_WAIT' in str(error):
                    print("      â³ Rate limit - Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï€ÎµÏÎ¹Î¼Î­Î½ÎµÏ„Îµ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿")

                # Show full error for debugging
                print(f"      ğŸ” Full error: {error}")

            # Rate limiting (ÏƒÎ·Î¼Î±Î½Ï„Î¹ÎºÏŒ!)
            if i < len(phone_list):
                print(f"      â³ Î ÎµÏÎ¯Î¼ÎµÎ½Îµ {delay} Î´ÎµÏ…Ï„ÎµÏÏŒÎ»ÎµÏ€Ï„Î±...")
                await asyncio.sleep(delay)

        # Î¤ÎµÎ»Î¹ÎºÎ¬ Î±Ï€Î¿Ï„ÎµÎ»Î­ÏƒÎ¼Î±Ï„Î±
        clear_output(wait=True)
        print("ğŸ‰ ÎŸÎ›ÎŸÎšÎ›Î—Î¡Î©Î˜Î—ÎšÎ•!")
        print("=" * 50)
        print(f"ğŸ“Š Î‘Î ÎŸÎ¤Î•Î›Î•Î£ÎœÎ‘Î¤Î‘:")
        print(f"âœ… Î•Ï€Î¹Ï„Ï…Ï‡Î®: {results['sent']}")
        print(f"âŒ Î‘Ï€Î¿Ï„Ï…Ï‡Î¯ÎµÏ‚: {results['failed']}")
        print(f"ğŸš« Blocked by users: {results['blocked']}")
        print(f"ğŸ“ˆ Î•Ï€Î¹Ï„Ï…Ï‡Î¯Î±: {results['sent']/results['total']*100:.1f}%")

        if results['errors']:
            print(f"\nâŒ DETAILED ERRORS:")
            for error in results['errors'][:5]:
                print(f"   ğŸ“± {error}")
            if len(results['errors']) > 5:
                print(f"   ... ÎºÎ±Î¹ {len(results['errors'])-5} Î±ÎºÏŒÎ¼Î±")

    async def stop_session(self):
        """Î¤Î­Î»Î¿Ï‚ session"""
        await self.app.stop()
        print("ğŸ”’ Session Ï„ÎµÏÎ¼Î±Ï„Î¯ÏƒÏ„Î·ÎºÎµ")

# Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± user sender
user_sender = TelegramUserSender(API_ID, API_HASH, PHONE_NUMBER)
print("âœ… User Account Sender Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®Î¸Î·ÎºÎµ!")

# =============================================================================
# CELL 4: Test User Connection
# =============================================================================
async def test_user_connection():
    """Î”Î¿ÎºÎ¹Î¼Î¬Î¶ÎµÎ¹ user account connection"""
    if API_HASH == "your_api_hash_here":
        print("âŒ Î’Î¬Î»Ï„Îµ Ï„Î± credentials!")
        return False

    try:
        await user_sender.start_session()
        print("ğŸ‰ User account connection ÎµÏ€Î¹Ï„Ï…Ï‡Î®Ï‚!")
        await user_sender.stop_session()
        return True

    except Exception as e:
        print(f"âŒ Connection error: {e}")
        if "phone_number" in str(e).lower():
            print("ğŸ’¡ Î’ÎµÎ²Î±Î¹Ï‰Î¸ÎµÎ¯Ï„Îµ ÏŒÏ„Î¹ Ï„Î¿ PHONE_NUMBER ÎµÎ¯Î½Î±Î¹ ÏƒÏ‰ÏƒÏ„ÏŒ")
        elif "api" in str(e).lower():
            print("ğŸ’¡ Î•Î»Î­Î³Î¾Ï„Îµ Ï„Î± API_ID ÎºÎ±Î¹ API_HASH")
        return False

# Î•ÎºÏ„Î­Î»ÎµÏƒÎ· test
await test_user_connection()

# =============================================================================
# CELL 5: Bulk Send Î±Ï€ÏŒ Excel
# =============================================================================
async def bulk_send_excel():
    """ÎœÎ±Î¶Î¹ÎºÎ® Î±Ï€Î¿ÏƒÏ„Î¿Î»Î® Î±Ï€ÏŒ Excel"""

    # Upload Excel
    print("ğŸ“‚ Î‘Î½ÎµÎ²Î¬ÏƒÏ„Îµ Ï„Î¿ Excel:")
    from google.colab import files
    uploaded = files.upload()

    if not uploaded:
        return

    excel_file = list(uploaded.keys())[0]

    try:
        # Read Excel
        df = pd.read_excel(excel_file)
        print(f"ğŸ“Š Excel columns: {list(df.columns)}")

        # Phone column
        phone_col = input("ğŸ“± Phone column name: ").strip()
        if phone_col not in df.columns:
            print(f"âŒ Column '{phone_col}' not found!")
            return

        # Clean phones
        phones = df[phone_col].dropna().astype(str).tolist()
        clean_phones = []

        for phone in phones:
            clean = ''.join(filter(str.isdigit, phone))
            if len(clean) >= 10:
                if clean.startswith('69') and len(clean) == 10:
                    clean_phones.append(f'+30{clean}')
                elif clean.startswith('3069'):
                    clean_phones.append(f'+{clean}')
                else:
                    clean_phones.append(f'+{clean}')

        print(f"ğŸ“± Valid phones: {len(clean_phones)}")

        # Message
        MESSAGE = input("ğŸ’¬ Your message: ").strip() or """ğŸ‰ Special Offer!

Hello! We have a great offer for you:
âœ¨ 50% discount on all products
â° Limited time only!

Visit: https://www.yourstore.com

Thank you! ğŸ™"""

        print(f"\nğŸ“‹ SUMMARY:")
        print(f"   ğŸ“± Phones: {len(clean_phones)}")
        print(f"   ğŸ’¬ Message: {MESSAGE[:50]}...")

        # Confirmation
        confirm = input(f"\nâ“ Send to {len(clean_phones)} phones? (yes/no): ")

        if confirm.lower() in ['yes', 'y']:
            print("ğŸš€ Starting bulk send...")

            # Start session
            await user_sender.start_session()

            # Send
            results = await user_sender.bulk_send_simple(clean_phones, MESSAGE)

            # Stop session
            await user_sender.stop_session()

            print(f"\nğŸŠ DONE! Sent {results['sent']} messages successfully!")

        else:
            print("âŒ Cancelled")

    except Exception as e:
        print(f"âŒ Error: {e}")

# Run bulk send
await bulk_send_excel()

# =============================================================================
# CELL 6: Single Test Message
# =============================================================================
async def single_test():
    """Test Î¼Îµ Î­Î½Î± Ï„Î·Î»Î­Ï†Ï‰Î½Î¿"""

    test_phone = input("ğŸ“± Test phone (+306912345678): ").strip()
    test_msg = "ğŸ§ª Test message Î±Ï€ÏŒ User Account API!"

    if test_phone:
        print(f"ğŸ“± Sending to: {test_phone}")

        await user_sender.start_session()
        result = await user_sender.send_to_phone(test_phone, test_msg)
        await user_sender.stop_session()

        if result['success']:
            print("âœ… Test successful!")
        else:
            print(f"âŒ Test failed: {result['error']}")

"""# Telegram User Account Sender Documentation

This project provides a Python script to send messages from a Telegram user account to phone numbers, supporting both single message sending and bulk sending from an Excel file.

## Features

-   **User Account Integration**: Connects to Telegram using a user's API ID, API Hash, and phone number.
-   **Single Message Send**: Send a message to a specific phone number.
-   **Smart Contact Handling**: Attempts to send messages directly, and if that fails, tries to import the contact and then send, or resolve the user.
-   **Bulk Sending from Excel**: Reads phone numbers from an Excel file and sends a predefined message to all valid numbers with configurable delays.
-   **Rate Limit Handling**: Includes basic rate-limiting awareness with configurable delays between messages to avoid flood waits.

## Setup

### 1. Install Dependencies

Run the first cell in the notebook to install all necessary libraries:

```python
!pip install pyrogram tgcrypto pandas openpyxl -q
```

### 2. Configure API Credentials

Update `CELL 2` with your Telegram API credentials. You can obtain these from [my.telegram.org](https://my.telegram.org/). Make sure to use your **user account API** credentials, not a bot token.

-   `API_ID`: Your API ID.
-   `API_HASH`: Your API Hash.
-   `PHONE_NUMBER`: Your Telegram phone number (e.g., `+3069XXXXXXXX`).

```python
API_ID =  # Replace with your API ID
API_HASH = "" # Replace with your API Hash
PHONE_NUMBER = "" # Replace with your phone number
```

**Important**: If `API_HASH` is still `"your_api_hash_here"`, the script will prompt you to update it.

## Usage

### 1. Test User Account Connection

Run `CELL 4` (`test_user_connection()`) to verify that your API credentials are correct and that the script can successfully connect to your Telegram account.

```python
await test_user_connection()
```

### 2. Send a Single Test Message

To send a single message to a specific phone number, run `CELL 6` (`single_test()`). You will be prompted to enter a test phone number.

```python
await single_test()
```

### 3. Bulk Send Messages from Excel

To send messages to multiple phone numbers from an Excel file, run `CELL 5` (`bulk_send_excel()`).

**Expected Excel Format**:

The Excel file should contain a column with phone numbers. The column name will be specified during execution.

**Steps:**

1.  Run the `bulk_send_excel()` function.
2.  You will be prompted to upload your Excel file.
3.  After uploading, the script will display the columns found in your Excel file. You will then be asked to enter the exact name of the column containing the phone numbers.
4.  You will be prompted to enter the message you wish to send. A default message is provided if you leave it blank.
5.  A summary of the operation will be displayed, and you will be asked for confirmation before sending the messages.
6.  The script will then proceed with sending messages, showing progress and detailed results.

```python
await bulk_send_excel()
```

## Error Handling & Notes

-   **Rate Limits (`FLOOD_WAIT`)**: Telegram imposes rate limits. The `bulk_send_simple` function includes a delay between messages to mitigate this. If you encounter `FLOOD_WAIT` errors, consider increasing the `delay` parameter in the `bulk_send_simple` method.
-   **Privacy Settings**: Some users may have privacy settings that prevent direct messages from non-contacts. The script attempts workarounds (contact import), but some messages may still fail due to user privacy settings.
-   **Invalid Phone Numbers**: The script attempts to clean phone numbers (e.g., adding `+30` for Greek numbers), but ensures your Excel data is as clean as possible.
-   **Session Management**: The script starts and stops the Pyrogram session for each operation (`start_session()` and `stop_session()`). This ensures resources are managed correctly.
"""